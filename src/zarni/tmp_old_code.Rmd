---
title: "Tmp_OldCode"
author: "Zarni Htet"
date: "March 30, 2018"
output: github_document
---


**Step 10: Recombine the Singleton and Non-Singleton Data Sets**

```{r}
combined_data <- rbind(non_singleton_data, singleton_NA_filled)
View(combined_data)
```

**Step 11: Split the combined data set by the Subject ID**

Here we are spliting the data set by subject ID so that we can apply the
interpolation function to each of the Subject ID

```{r}
#Split the data by subject ID
combined_data_split <- split(combined_data, combined_data[,1])

```

**Step 12: Build Custom Function to Handle Interpolation**

There are two custom functions in this section that allow us to use the approx function (details of the function are in the Appendix) for interpolation for our data set.
A couple of steps are involved to prepare to apply the approx function.
- Figuring out the Vectors and its corresponding indexes to interpolate
- Defining the minimum and maximum values in existing data set to apply LOCF/LOCB to tail missing NAs
- Using a secondary custom function to merge the outputs of Approxfunction from multiple vectors to a single data frame

```{r}

#Wrapper! Passes to a function:
#Use ... Need to write it out!
#The function will take in a data frame as well as an input vector that specifies which column indexes of the data frame are of interest for the interpolation. The reason we have the input vector is that it give us a flexible to use single function which can deal with a large data frame where multiple columns may need interpolation.

#df refers to the data frame of interest
#par is a vector that specifies the TWO indexes: 1 being time in this case and the other being the missing column index
mdz_interpolate <- function(df, par){
  #Saving the data frame in a local variable
  x <- df
  #Pulling out the index for X vector (In our case Time)
  x_1 <- par[1]
  #Pulling out the index for Y Vector 1 (In our case BMI)
  y_1 <- par[2]
  #Pulling out the index for Y Vector 2 (In our case Media)
  y_2 <- par[3]
  #Pulling out x and y vectors for the interpolation
  #They are in data frame format.You have to unlist and make it a numeric vector.
  xx <- as.numeric(unlist(x[,x_1])) # X vector
  yy_1 <- as.numeric(unlist(x[,y_1])) # Y vector 1
  yy_2 <- as.numeric(unlist(x[,y_2])) # Y vector 2
  #Specifying indexes where we had to fill with the missing NA for y Vector 1
  xout_1 <- which(is.na(yy_1))
  #specifying indexes where we had to fill with the missing NA for y Vector 2
  xout_2 <- which(is.na(yy_2))
  #Specifying the minimum and maximum values for Last Value Carried Backward/Forward
  #Get the non-missing indexes first
  y_nmis_1 <- which(!is.na(yy_1))
  y_nmis_2 <- which(!is.na(yy_2))
  #Get the value from the furthest left index of Y (LOCB)
  y_min_1 <- yy_1[min(y_nmis_1)]
  y_min_2 <- yy_2[min(y_nmis_2)]
  #Get the value from the furthest right index of Y (LOCF)
  y_max_1 <- yy_1[max(y_nmis_1)]
  y_max_2 <- yy_2[max(y_nmis_2)]
  #Apply this to the interpolation function (Explanations of the function are in Appendix section)
  #The interpolation for the first vector
  out_1 <- approx(xx, yy_1, xout = xout_1,  method = "linear", yleft = y_min_1, yright = y_max_1, rule = 2)
  #The interpolation for the second vector
  out_2 <- approx(xx, yy_2, xout = xout_2, method = "linear", yleft = y_min_2, yright = y_max_2, rule = 2)
  #The missing values replaced data frame 1 of replaced Vector 1
  outframe_1 <- d_replace(x, out_1, 3)
  #The missing values replaced data frame 2 of replaced Vector 2
  outframe_2 <- d_replace(x, out_2, 4)
  outframe_1[,4] <- outframe_2[,4]
  return(outframe_1)
}
```

Helper Function that puts missing values back into the data frame.

```{r}
#The function takes in an actual data frame (df), an Robject of the interpolation function which contains the index values that has been replaced under vector x and the values that has been imputed under vector y. Then, we specify the column to which those values are replaced with rcol
d_replace <- function(df, robj, rcol){
  
  #saving the local data frame
  df <- df
  #saving the local robject
  robj <- robj
  #specifying the rows and the columns to replace the R values by
  df[robj$x,rcol] <- robj$y 
  return(df)
}
```

**Step 13: Applies the Custom Interpolation Function to the Split data set**

This section applies the **split** dataframe into the custom linear interpolation function from above. By split data, it means here that we are handling each subjectID spearately using lapply functions.

```{r}
#The split data is put in and then, the time column: 2, the BMI column: 3 and the media column 4 are applied the interpolation function
c_data_interp <- lapply(combined_data_split, mdz_interpolate, par=c(2,3,4))
```

**Step 14: Collapse the Split Data Into a Single Data Frame**

```{r}
#Use dplyr bind_rows to recompose the split data together
#http://dplyr.tidyverse.org/reference/bind.html
c_data_interp_bind <- bind_rows(c_data_interp)
```

```{r}
head(c_data_interp_bind)
#Converting the squared transformation back to to square root transformation 
c_data_interp_bind$Media <- sqrt(c_data_interp_bind$Media)
head(c_data_interp_bind)
```


```{r}
write.csv(c_data_interp_bind, "../../data/final/final_interp_data.csv")
```






### APPENDIX:

#### Section I: Theorectical Explanation

##### Base Linear Interpolation Function

The linear interpolation equation to be used in the base function is below. The $y_{0}$ and $y_{1}$ would be either BMI or Media exposure variable. The $x_{0}$ and $x_{1}$ would be the time variable.

The $y$ variable is the missing value we are looking for at time $x$. For BMI variable, the $x$ corresponds to time from Media exposure that is missing between the $x_{0}$ and the $x_{1}$ intervals. The converse can be said of the Media Exposure variable to BMI as well. 

Source: Linear Interpolation, Wikipedia
$$
y = y_{0} + (x - x_{0}) \frac{y_{1}- y_{0}}{x_{1} - x_{0}}
$$


This section deals with testing out functions and other stuffs

Use ApproxFun:
https://stat.ethz.ch/R-manual/R-devel/library/stats/html/approxfun.html

#### Section II: Testing the Approx Function

##### START: Testing Out Linear Interpolation approx/approxfun

Both approx and approxfun looks fairly similar.
There are a couple of **key parameters** to consider
* x,y => input vectors
* xout => we specify which indexes we want to interpolate    values for
* yleft => this is specifying the last value to be carried to the left or backward if x values are less than min(x) 

* yright => this is specifying the last value to be carried to the right or forward if x values are more than max(x)

* rule => Two options. 1 is to get NA for yleft, yright case. 2 is to output yleft, yright cases

###### Test Case 1

This is a simple case of some missing Ys with X values.
A manual calculation is done below to verify the answer.



This helper function puts back the output to the actual data frame.

Simulated data 1
```{r}
x_1 <- c(1,2,3,4,5,6)
y_1 <- c(3,NA,5,NA,NA,10)
xout_1 <- which(is.na(y_1)) #which returns the indexes where y_1 vector has NA values
```

Specifying y_left and y_right

This code chunk will tackle the case of last carried left/backward and last carried right/forward. The goal is to find the furthest left y index that is not NA and save the value. The same goes for the furthest right.

```{r}
y_nmis_1 <- which(!is.na(y_1)) #indexes of non-missing y values
y_min_1 <- y_1[min(y_nmis_1)] #get the value from the furtherest left index of y 
y_max_1 <- y_1[max(y_nmis_1)] #get the value from the furthest right index of y
```

Applying the function

This code chunk applies the function

```{r}
out_1 <- approx(x_1, y_1, xout = xout_1,  method = "linear", yleft = y_min_1, yright = y_max_1, rule = 2)
```

Interpolated results
```{r}
print(out_1$y)
```

Manual calculation to confirm it.

Notetoself: In the future, helper functions should be in a separate source file. Seek permission from MS/DH.

Base interpolation helper function

```{r}
#Note: Come back and write more comments later.

#The function takes in two pairs of point and the point you want to interpolate
lin_interpol <- function(y0,y1,x0,x1,x){
  y <- y0 + (x-x0) * ((y1-y0)/(x1-x0))
  return(y)
}
```

Manually outputting the three NA values from above

```{r}
res_1_1 <- lin_interpol(3,5,1,3,2)
print(res_1_1)
res_2_1 <- lin_interpol(5,10,3,6,4)
print(res_2_1)
res_3_1 <- lin_interpol(5,10,3,6,5)
print(res_3_1)
```

All the results matches up. We only have a case of Last Value Carried forward and backward to test

###### Test Case 2

Simulated data 2

We are testing the case of last value carried forward with 1 value missing on the left and 2 values missing on the right
```{r}
x_2 <- c(1,2,3,4,5,6)
y_2 <- c(NA,3,5,10,NA,NA)
xout_2 <- which(is.na(y_2)) #which returns the indexes where y_1 vector has NA values
```

Same as above (Comments to merge or fill in later)

```{r}
y_nmis_2 <- which(!is.na(y_2)) #indexes of non-missing y values
y_min_2 <- y_2[min(y_nmis_2)] #get the value from the furtherest left index of y 
y_max_2 <- y_2[max(y_nmis_2)] #get the value from the furthest right index of y
```

This code chunk applies the function

```{r}
out_2 <- approx(x_2, y_2, xout = xout_2,  method = "linear", yleft = y_min_2, yright = y_max_2, rule = 2)
```

Interpolated results
```{r}
print(out_2$y)
```
Perfect. Left value carried forward and right value carried forward works like a charm.









