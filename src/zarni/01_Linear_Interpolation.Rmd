---
title: "01_Linear_Interpolation"
author: "Zarni Htet (zh938@nyu.edu)"
output:
  pdf_document: default
  html_notebook: default
---

###Linear Interpolation

This Markdown is filling the missing data for BMI and media exposure at asynchronous time points using linear interpolation. The project is supervised by Professor Marc Scott and Professor Daphna Harel. The data is from the Belle Lab at the Bellevue Hospital. More details of the project scope in the repository under lit folder.

#### R Libraries

This code block has all the needed R libraries

```{r}
#For the dta raw files
library(foreign)
#For importing different types of data set without specification
library(rio)
#For processing long form data
library(dplyr)

```

#### Uploading Raw data

In this code chunk, we are uploading raw .dta data and converting to it a csv. This will then be saved to a processing data folder to protect the integrity of the raw data.

```{r}
#The BMI data extract
bmi <- read.dta("../../data/raw/MASextract1.dta")
#The Media data extract
media <- read.dta("../../data/raw/MASextract2.dta")
#Writing the BMI data to processing file
write.csv(bmi, "../../data/processing/bmi.csv")
#Writing the media data to processing file
write.csv(media, "../../data/processing/media.csv")
```

#### Loading the Data back from Processing Folder

This code chunk is loading the working version of the data extra to be used throughout the document.

```{r}
#processing bmi data
p_bmi <- import("../../data/processing/bmi.csv")
p_media <- import("../../data/processing/media.csv")
```

#### Data Exploration

This code chunks examine the two data sets. In particular, the focus here is on the key variables and the time intervals they are recorded. At the end of each code block for each data set, there is a short summary of what the data consists of.

#####The BMI data set overview

```{r}
head(p_bmi)
tail(p_bmi)
dim(p_bmi) #10326, 4
#check the number of unique subjects
length(unique(p_bmi$ID_)) #667 
length(unique(p_bmi$AgeMos)) #1951
print(sum(is.na(p_bmi$ID_))) #0 no values are missing here
print(sum(is.na(p_bmi$AgeMos))) #0 no values are missing here
```

Each subject has different time points. For subject 1, months may be 0, 0.5, 1.0 while subject 2 has months in 0, 0.7, 1.2 etc.


This is to explore the number of time intervals each subject has. 

```{r}
#This uses dplyr to group by each subject and count their instances. This effectively counts the number of time points each of them have.
bmi_timed <- p_bmi %>% 
  group_by(ID_) %>%
  summarize(n = n()) 
print(bmi_timed)
```

We will do a quick barplot to see the distribution of time points for each subject has

```{r}
#Using the table function and barplot to draw the distribution of time. 
barplot(table(bmi$ID_), main = "Time Count Distribution \n for Each Subject for BMI")
```

Check the Minimum/Maximum time intervals. This is to see if we have to explore edge cases later down the road for Last Value Carried forward at the end for each subject

```{r}
min(bmi_timed$n) #1
max(bmi_timed$n) #39
```

At least 1 subject has only 1 time interval for BMI.

##### Media exposure data set overview

```{r}
head(p_media)
tail(p_media)
dim(p_media) #1639, 5
#check the number of unique subjects
length(unique(p_media$ID_)) #542 
length(unique(p_media$AgeMos)) #745
print(sum(is.na(p_media$ID_))) #0
print(sum(is.na(p_media$AgeMos))) #0
```

This is to explore the number of time intervals each subject has. 

```{r}
#This uses dplyr to group by each subject and count their instances. This effectively counts the number of time points each of them have.
media_timed <- p_media %>% 
  group_by(ID_) %>%
  summarize(n = n()) 
print(media_timed)
```

Like the BMI from before, each subject has different count of time as well as time intervals where the data is collected.

```{r}
#Using the table function and barplot to draw the distribution of time. 
barplot(table(bmi$ID_), main = "Time Count Distribution \n for Each Subject for Media Exposure")
```

#####Cleaning data

In this section, I will attempt to discover the subjects that only have 1 data point for the BMI data set or the Media exposure data set. These will have to be removed from the working data set as Linear interpolation cannot happen unless we have more than 1 data point. Those subjects will be noted down and saved in a separate file.


###### BMI cleaning

Figuring out the 1 data point subjects and saving it them to an output file.

```{r}
#Recalling the count by ID dataset from above for BMI.
head(bmi_timed)
#Getting the indexes for which n = 1
#An assumption has been that for each row, there is no missing corresponding time value or bmi value. This assumption holds because of the missingness checks above.
bmi_exclude <- bmi_timed[bmi_timed$n==1,]
print(bmi_exclude)
write.csv(bmi_exclude, "../../data/final/bmisubjects_withonedatap.csv")
```

There are 3 subjects with 1 data point and has been saved to an output file.

Removing the 3 subjects from the processing BMI file by their ID.

```{r}
dim(p_bmi)#checking the dimensions of p_bmi before removing
p_bmi <- p_bmi[!(p_bmi$ID_ %in% bmi_exclude$ID_), ] #removing by a logical vector where we want all the subject IDs except those from the exclusion criteria
dim(p_bmi)
```

###### Media exposure cleaning

Figuring out the 1 data point subjects and saving it them to an output file.

```{r}
#Recalling the count by ID dataset from above for Media exposure.
head(media_timed)
#Getting the indexes for which n = 1
#An assumption has been that for each row, there is no missing corresponding time value or media value. This assumption holds because of the missingness checks above.
media_exclude <- media_timed[media_timed$n==1,]
print(media_exclude)
write.csv(media_exclude, "../../data/final/mediasubjects_withonedatap.csv")
```

There are 100 subjects in media exposure file that only has 1 data point. 

Removing the 100 subjects from the processing BMI file by their ID.

```{r}
dim(p_media)#checking the dimensions of p_bmi before removing
p_media <- p_media[!(p_media$ID_ %in% media_exclude$ID_), ] #removing by a logical vector where we want all the subject IDs except those from the exclusion criteria
dim(p_media)
```
##### Output 

This is to build redundancy of data sets should code be accidentally changed etc. The data will be saved in the final data folder.

Output

*bmi_clean_1 has removed 3 subjects with 1 data point
*media_clean_1 has removed 100 subjects with 1 data point

```{r}
#write.csv(p_bmi,"../../data/final/bmi_clean_1.csv")
#write.csv(p_media, "../../data/final/media_clean_1.csv")
```

####Merging the two data sets

#####Check the number of ID matches between the two files

The two ids to merge across the data sets are not of equal length. We will use the smaller one as base and see how much more are missing.

```{r}
#Writing in the Media Exposure Smaller one first to fill in
matched_index <- match(p_media$ID_, p_bmi$ID_)
#Checking the number of non matches using is.na
non_matches <- sum(is.na(matched_index))
print(non_matches) #19
#Checking total matches by substracting from maximum unique ID of smaller set to the missing ones
total_matches <- length(unique(p_media$ID_)) - non_matches
print(total_matches) #423
#This is not perfect total number. The best way is to match it to match the IDs by innerjoin and capture the NA values
```

#####Join the two tables to fill in missing Xs and missing Ys for Each Subject

This is where we join by the patient ID to only those subjects that exist in both datasets. Therefore, we will only be using innerjoin. We will also be expanding BMI time points for where Media exposure exists and vice versa.

```{r}


```

#####Base Linear Interpolation Function

The linear interpolation equation to be used in the base function is below. The $y_{0}$ and $y_{1}$ would be either BMI or Media exposure variable. The $x_{0}$ and $x_{1}$ would be the time variable.

The $y$ variable is the missing value we are looking for at time $x$. For BMI variable, the $x$ corresponds to time from Media exposure that is missing between the $x_{0}$ and the $x_{1}$ intervals. The converse can be said of the Media Exposure variable to BMI as well. 

Source: Linear Interpolation, Wikipedia
$$
y = y_{0} + (x - x_{0}) \frac{y_{1}- y_{0}}{x_{1} - x_{0}}
$$


Use ApproxFun:
https://stat.ethz.ch/R-manual/R-devel/library/stats/html/approxfun.html

##### START: Testing Out Linear Interpolation approx/approxfun

Both approx and approxfun looks fairly similar.
There are a couple of **key parameters** to consider
* x,y => input vectors
* xout => we specify which indexes we want to interpolate    values for
* yleft => this is specifying the last value to be carried to the left or backward if x values are less than min(x) 

* yright => this is specifying the last value to be carried to the right or forward if x values are more than max(x)

* rule => Two options. 1 is to get NA for yleft, yright case. 2 is to output yleft, yright cases

######Test Case 1

This is a simple case of some missing Ys with X values.
A manual calculation is done below to verify the answer.

Simulated data 1
```{r}
x_1 <- c(1,2,3,4,5,6)
y_1 <- c(3,NA,5,NA,NA,10)
xout_1 <- which(is.na(y_1)) #which returns the indexes where y_1 vector has NA values
```

Specifying y_left and y_right

This code chunk will tackle the case of last carried left/backward and last carried right/forward. The goal is to find the furthest left y index that is not NA and save the value. The same goes for the furthest right.

```{r}
y_nmis_1 <- which(!is.na(y_1)) #indexes of non-missing y values
y_min_1 <- y_1[min(y_nmis_1)] #get the value from the furtherest left index of y 
y_max_1 <- y_1[max(y_nmis_1)] #get the value from the furthest right index of y
```

Applying the function

This code chunk applies the function

```{r}
out_1 <- approx(x_1, y_1, xout = xout_1,  method = "linear", yleft = y_min_1, yright = y_max_1, rule = 2)
```

Interpolated results
```{r}
print(out_1$y)
```

Manual calculation to confirm it.

Notetoself: In the future, helper functions should be in a separate source file. Seek permission from MS/DH.

Base interpolation helper function

```{r}
#Note: Come back and write more comments later.

#The function takes in two pairs of point and the point you want to interpolate
lin_interpol <- function(y0,y1,x0,x1,x){
  y <- y0 + (x-x0) * ((y1-y0)/(x1-x0))
  return(y)
}
```

Manually outputting the three NA values from above

```{r}
res_1_1 <- lin_interpol(3,5,1,3,2)
print(res_1_1)
res_2_1 <- lin_interpol(5,10,3,6,4)
print(res_2_1)
res_3_1 <- lin_interpol(5,10,3,6,5)
print(res_3_1)
```

All the results matches up. We only have a case of Last Value Carried forward and backward to test

######Test Case 2

Simulated data 2

We are testing the case of last value carried forward with 1 value missing on the left and 2 values missing on the right
```{r}
x_2 <- c(1,2,3,4,5,6)
y_2 <- c(NA,3,5,10,NA,NA)
xout_2 <- which(is.na(y_2)) #which returns the indexes where y_1 vector has NA values
```

Same as above (Comments to merge or fill in later)

```{r}
y_nmis_2 <- which(!is.na(y_2)) #indexes of non-missing y values
y_min_2 <- y_2[min(y_nmis_2)] #get the value from the furtherest left index of y 
y_max_2 <- y_2[max(y_nmis_2)] #get the value from the furthest right index of y
```

This code chunk applies the function

```{r}
out_2 <- approx(x_2, y_2, xout = xout_2,  method = "linear", yleft = y_min_2, yright = y_max_2, rule = 2)
```

Interpolated results
```{r}
print(out_2$y)
```
Perfect. Left value carried forward and right value carried forward works like a charm.

##### END: Testing Out Linear Interpolation approx/approxfun

##### Applying approx to Curated Data Set

```{r}



```









##### To Be Archived as R function is working as it should

Filling using Base Function above Function

```{r}
#Parameters, X and Y values of each subject with missing NAs for the Y values

#Within function
## skip the first time point
## from the second time point and onwards
### if a missing NA is encountered for Y, go to the non-missing X and Y pair and the next one before. 
### Calculate the time points in between.

#This could be much easily done if I use indexes of missing and non-missing.
##Have an index vector with the two X and Ys.
## Missing indexes can be two types
### It could be an index of count 1 and multiple
### For either case, pick the x0 and y0 and fill it up
```

Applying for Last Value Carried Forward Function

```{r}
#Apply Last Value Carried Forward/Backward for the values
```

Applying to all the subjects function
```{r}

```

Execution of the Functions

```{r}
#All BMI subjects
```

```{r}
#All Media Exposure subjects
```


























